<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSAP Scroll Animation</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
    <div class="w-full bg-zinc-600">
        <div class="parent relative top-0 left-0 w-full h-[700vh]">
            <div class="w-full h-screen sticky top-0 left-0">
                <canvas class="w-full h-screen" id="frame"></canvas>
            </div>
        </div>
    </div>

    <!-- GSAP and ScrollTrigger -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

    <script>
        gsap.registerPlugin(ScrollTrigger);

        const canvas = document.getElementById("frame");
        const context = canvas.getContext("2d");

        // --- Configuration ---
        const config = {
            // Total number of frames in the image sequence
            frameCount: 17,
            // Function to generate the path for each image frame.
            // Assumes images are 1-indexed (e.g., output_frame_0001.jpg).
            imagePath: (index) => `./video/image_frame/output_frame_${index.toString().padStart(4, "0")}.jpg`,
            // A higher scrub value creates a smoother, more delayed "catch-up" effect.
            scrub: 2,
        };

        // --- State ---
        const animationState = {
            // The current frame index being displayed, which GSAP will animate.
            currentFrame: 0,
        };
        const images = []; // Array to hold all preloaded image objects

        // --- Canvas Functions ---
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function drawImage(index) {
            // Ensure index is a valid integer within the images array bounds
            const frameIndex = Math.floor(index);
            if (frameIndex < 0 || frameIndex >= images.length) return;

            const img = images[frameIndex];
            // Ensure the image is fully loaded before attempting to draw
            if (!img || !img.complete || img.naturalWidth === 0) return;

            // Clear the canvas for the new frame
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate aspect ratio to "cover" the canvas without distortion
            const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;

            // Center the image on the canvas
            const offsetX = (canvas.width - scaledWidth) / 2;
            const offsetY = (canvas.height - scaledHeight) / 2;

            context.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
        }

        // --- Animation Setup ---
        function preloadImages() {
            const promises = [];
            // Loop from 1 to frameCount based on file naming convention
            for (let i = 1; i <= config.frameCount; i++) {
                const promise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(`Failed to load image: ${config.imagePath(i)}`);
                    img.src = config.imagePath(i);
                    images.push(img); // Add image to array for later access
                });
                promises.push(promise);
            }
            return Promise.all(promises);
        }

        function setupScrollAnimation() {
            gsap.to(animationState, {
                currentFrame: config.frameCount - 1, // Animate from frame 0 to the last one
                ease: "none",
                scrollTrigger: {
                    trigger: ".parent",
                    start: "top top",
                    end: "bottom top", // Animate over the full height of the trigger
                    scrub: config.scrub,
                },
                onUpdate: () => drawImage(animationState.currentFrame),
            });
        }

        // --- Main Execution ---
        async function main() {
            setCanvasSize();
            await preloadImages();
            drawImage(0); // Draw the first frame initially
            setupScrollAnimation();

            window.addEventListener("resize", () => {
                setCanvasSize();
                drawImage(animationState.currentFrame);
            });
        }

        main();
    </script>
</body>

</html>